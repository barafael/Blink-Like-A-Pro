# Intro
About me (studied here, work now)
Quick facts about my interests: systems software that does not (and must not) fail.
Quick funny rant about work place (TODO get factoids from notebook)

Last talk was about getting hardware to run. Now, I work at a company where people are paid to do this right for me.
So this talk is about embedded software.
Goal is not to teach C or C++, and goal is not to make you embedded developer in 45 minutes (that's a different talk).
Instead, goal is to give a quick safari about the topics I find important for getting started/intermediate level.

# Blocking Blinky
Show basic blinky (with registers/assembler/linker, bare minimum example) - this will frighten some.
Then use C and the ST HAL and CubeMX with debugger and SFR view. Little joke: kill debugging pins from SFR view.
Emphasize that memory is not just flip flops - there could be a gpio pin, or any other periphery.
Reading/writing to memory in C: *0xdeadbeef = SOME_VALUE; might not store SOME_VALUE, there can be just any periphery at 0xdeadbeef.
Emphasize that we are using the processor to put bits in registers by showing a simple blocking UART with sermon.
Show non-blocking sequential without delay - this is essentially a form of 'yield' with scheduler.

# Timer Blinky
Theory: in the previous example, what was HAL_Delay(millis)? Based on clock cycles? Could be, but not portable and inaccurate.
Instead: a timer is used. Explain counter, PERIOD, PRESCALER, equation.
Show timer config in Cube. Show Clock Tree in Cube.
Theory: interrupts. Discuss asynchronicity, how the real world is really asynchronous and parallel, and blocking waiting is bad when you want to do any work (might miss events).
Discuss interrupt priorities, preemption levels, NVIC? There is no back-preemption, without scheduler, hence stupid lock is safe.
Show interrupt on timer update / output compare event. Toggle LED. Main loop is empty! But processor is still busy shuffling bits around.
To emphasize, show reading the ADC with interrupts. Show value in STM Studio? Would need windows. Or segger system view?

# DMA Blinky
Theory: data pump. Can be connected by both ends to peripherals or memory. As peripherals just live in the memory layout, moving data to/from there is the same as moving data in memory.
Like memcpy, except that the processor does not move a finger! No interrupts, either.
Show timer triggering a DMA transfer to GPIOx->BSRR.
Example: ws2812 driver. Show how C++ can be used together with HAL (friend functions, extern "C", handles, RAII).

# RTOS Blinky
Show how simple setting up freertos is in CubeMX. Start a few tasks.
What is the benefit? Decoupling, and a cheap way to REDUCE power consumption (wfi, tickless wait).

# Code Generation Tools
Shout out to CubeMX. How do they do that?!
.svd file format: show snippet.
This looks almost like one could generate entire APIs from it.
-> svd2rust: generates type-safe HAL from svd files! Meaning that it is impossible to write to a read-only register, and many other benefits, at compile time.
embedded-hal: uses that autogenerated HAL and builds higher abstractions on it. These evaporate away (this is Rust).
Open new opportunities: Can be mocked, or simulated, great for testing and formal techniques.
Show the GPIO output pin example where a pin cannot be misused as in/output - this is typestate programming.
I see a lot of potential for Rust for systems software that must be highly robust and performant.
Damn it! I did it again. I turned a perfectly fine talk into a Rust commercial.
The downside is apparent: C is way simpler initially. The ecosystem is still changing rapidly. Rust is very challenging and rewarding to learn.

# Outro
